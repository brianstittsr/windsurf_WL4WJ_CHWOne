/**
 * Fix XLSX Vulnerability
 * 
 * This script addresses the high severity vulnerability in the xlsx package
 * by replacing it with the safer exceljs package.
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

console.log('Starting XLSX vulnerability fix...');

// Path to the DataProcessingService file
const dataProcessingServicePath = path.resolve(process.cwd(), 'src/services/DataProcessingService.ts');

// Check if file exists
if (!fs.existsSync(dataProcessingServicePath)) {
  console.error('DataProcessingService not found at path:', dataProcessingServicePath);
  process.exit(1);
}

// Create backup
const backupPath = `${dataProcessingServicePath}.xlsx-fix-backup`;
fs.copyFileSync(dataProcessingServicePath, backupPath);
console.log(`Created backup of DataProcessingService at ${backupPath}`);

// Read the current content
const currentContent = fs.readFileSync(dataProcessingServicePath, 'utf8');

// Replace xlsx with exceljs
const updatedContent = currentContent
  // Replace import statement
  .replace(
    `import * as XLSX from 'xlsx';`,
    `import ExcelJS from 'exceljs';`
  )
  // Replace Excel processing function
  .replace(
    /private async processExcel\(filePath: string, fileName: string\): Promise<DataProcessingResult> {[\s\S]*?return { success: true, dataset };[\s\S]*?}/,
    `private async processExcel(filePath: string, fileName: string): Promise<DataProcessingResult> {
    try {
      const workbook = new ExcelJS.Workbook();
      await workbook.xlsx.readFile(filePath);
      
      // Get the first worksheet
      const worksheet = workbook.worksheets[0];
      if (!worksheet) {
        return {
          success: false,
          error: 'Excel file contains no worksheets'
        };
      }
      
      // Extract headers from the first row
      const headers: string[] = [];
      worksheet.getRow(1).eachCell((cell, colNumber) => {
        headers[colNumber - 1] = cell.value?.toString() || \`Column\${colNumber}\`;
      });
      
      // Extract data rows
      const rows: any[] = [];
      worksheet.eachRow((row, rowNumber) => {
        if (rowNumber === 1) return; // Skip header row
        
        const rowData: any = {};
        row.eachCell((cell, colNumber) => {
          const header = headers[colNumber - 1];
          rowData[header] = cell.value;
        });
        
        rows.push(rowData);
      });
      
      if (rows.length === 0) {
        return {
          success: false,
          error: 'Excel file contains no data rows'
        };
      }
      
      const dataset: ProcessedDataset = {
        id: \`dataset_\${Date.now()}\`,
        name: fileName,
        type: 'excel',
        originalFile: fileName,
        data: rows,
        columns: headers,
        rowCount: rows.length,
        createdAt: new Date(),
        metadata: {
          source: 'datafiles',
          description: \`Processed Excel spreadsheet: \${fileName}\`,
          tags: ['excel', 'spreadsheet']
        }
      };
      
      return { success: true, dataset };
    } catch (error) {
      return {
        success: false,
        error: \`Excel processing failed: \${error instanceof Error ? error.message : 'Unknown error'}\`
      };
    }
  }`
  );

// Write the updated content back to the file
fs.writeFileSync(dataProcessingServicePath, updatedContent);
console.log('Updated DataProcessingService.ts to use ExcelJS instead of xlsx');

// Update package.json to replace xlsx with exceljs
const packageJsonPath = path.resolve(process.cwd(), 'package.json');
if (fs.existsSync(packageJsonPath)) {
  // Create backup
  const packageJsonBackupPath = `${packageJsonPath}.xlsx-fix-backup`;
  fs.copyFileSync(packageJsonPath, packageJsonBackupPath);
  console.log(`Created backup of package.json at ${packageJsonBackupPath}`);

  // Read package.json
  const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));

  // Remove xlsx dependency
  if (packageJson.dependencies && packageJson.dependencies.xlsx) {
    delete packageJson.dependencies.xlsx;
    console.log('Removed xlsx dependency from package.json');
  }

  // Add exceljs dependency
  packageJson.dependencies = packageJson.dependencies || {};
  packageJson.dependencies.exceljs = '^4.4.0';
  console.log('Added exceljs dependency to package.json');

  // Write updated package.json
  fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
  console.log('Updated package.json');
}

// Check if there are any other files using xlsx
console.log('\nChecking for other files using xlsx...');

// Function to search for files with xlsx references
function searchForXlsxReferences() {
  const filesWithXlsxReferences = [];
  
  // Directories to search
  const directories = [
    'src/services',
    'src/components',
    'src/app',
    'src/utils'
  ];
  
  // Manual search
  const searchDirectory = (dir) => {
    const fullDir = path.resolve(process.cwd(), dir);
    if (!fs.existsSync(fullDir)) {
      console.log(`Directory not found: ${fullDir}`);
      return;
    }
    
    try {
      const entries = fs.readdirSync(fullDir, { withFileTypes: true });
      
      for (const entry of entries) {
        const fullPath = path.join(fullDir, entry.name);
        
        if (entry.isDirectory()) {
          searchDirectory(path.join(dir, entry.name));
        } else if (entry.isFile() && /\.(ts|tsx|js|jsx)$/.test(entry.name)) {
          try {
            const content = fs.readFileSync(fullPath, 'utf8');
            if (content.includes('xlsx') && !fullPath.includes('.backup') && !fullPath.includes('.bak')) {
              console.log(`Found xlsx reference in: ${fullPath}`);
              filesWithXlsxReferences.push(fullPath);
            }
          } catch (err) {
            console.error(`Error reading file ${fullPath}:`, err.message);
          }
        }
      }
    } catch (err) {
      console.error(`Error reading directory ${fullDir}:`, err.message);
    }
  };
  
  directories.forEach(searchDirectory);
  return filesWithXlsxReferences;
}

const filesWithXlsxReferences = searchForXlsxReferences();
console.log(`Found ${filesWithXlsxReferences.length} additional files with xlsx references`);

// Check bmad DataProcessingService
const bmadServicePath = path.resolve(process.cwd(), 'src/services/bmad/DataProcessingService.ts');
if (fs.existsSync(bmadServicePath) && filesWithXlsxReferences.includes(bmadServicePath)) {
  console.log('Updating bmad DataProcessingService...');
  
  // Create backup
  const bmadBackupPath = `${bmadServicePath}.xlsx-fix-backup`;
  fs.copyFileSync(bmadServicePath, bmadBackupPath);
  console.log(`Created backup of bmad DataProcessingService at ${bmadBackupPath}`);
  
  // Read content
  let bmadContent = fs.readFileSync(bmadServicePath, 'utf8');
  
  // Replace mock XLSX with mock ExcelJS
  bmadContent = bmadContent.replace(
    /const mockXLSX = {[\s\S]*?};/,
    `const mockExcelJS = {
  Workbook: class {
    worksheets = [{
      eachRow: (callback) => {
        callback([{ value: 'col1' }, { value: 'col2' }], 1);
        callback([{ value: 'value1' }, { value: 'value2' }], 2);
      },
      getRow: (rowNumber) => ({
        eachCell: (callback) => {
          callback({ value: 'col1' }, 1);
          callback({ value: 'col2' }, 2);
        }
      })
    }];
    xlsx = {
      readFile: async () => Promise.resolve()
    };
  }
};`
  );
  
  // Replace Excel parsing function
  bmadContent = bmadContent.replace(
    /private parseExcel\(buffer: ArrayBuffer\): any\[\] {[\s\S]*?}/,
    `private parseExcel(buffer: ArrayBuffer): any[] {
    try {
      // In a real implementation, we would use ExcelJS
      // For now, we'll return mock data
      const workbook = new mockExcelJS.Workbook();
      
      const rows: any[] = [];
      const headers: string[] = [];
      
      // Mock processing with our fake ExcelJS
      workbook.worksheets[0].getRow(1).eachCell((cell, colNumber) => {
        headers[colNumber - 1] = cell.value;
      });
      
      workbook.worksheets[0].eachRow((row, rowNumber) => {
        if (rowNumber === 1) return; // Skip header row
        
        const rowData: any = {};
        row.forEach((cell, index) => {
          rowData[headers[index]] = cell.value;
        });
        
        rows.push(rowData);
      });
      
      return rows;
    } catch (error) {
      console.error('Error parsing Excel:', error);
      throw new Error(\`Failed to parse Excel: \${error instanceof Error ? error.message : 'Unknown error'}\`);
    }
  }`
  );
  
  // Write updated content
  fs.writeFileSync(bmadServicePath, bmadContent);
  console.log('Updated bmad DataProcessingService');
}

console.log('\nXLSX vulnerability fix completed successfully!');
console.log('\nNext steps:');
console.log('1. Run "npm install" to update dependencies');
console.log('2. Test Excel file processing functionality');
console.log('3. Run "npm audit" to verify the vulnerability has been resolved');
