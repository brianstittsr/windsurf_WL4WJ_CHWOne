'use client';

import React, { useState, useEffect } from 'react';
import {
  Box,
  Stepper,
  Step,
  StepLabel,
  Button,
  Typography,
  Paper,
  TextField,
  FormControl,
  FormLabel,
  RadioGroup,
  FormControlLabel,
  Radio,
  Checkbox,
  Select,
  MenuItem,
  InputLabel,
  CircularProgress,
  Divider,
  Alert,
  Grid,
  SelectChangeEvent,
  Chip,
  List,
  ListItem,
  ListItemText
} from '@mui/material';
import { 
  ArrowForward as ArrowForwardIcon, 
  ArrowBack as ArrowBackIcon,
  Save as SaveIcon,
  Refresh as RefreshIcon,
  Description as DescriptionIcon,
  Check as CheckIcon,
  Lightbulb as LightbulbIcon
} from '@mui/icons-material';
import { useAuth } from '@/contexts/AuthContext';
import { FIELD_TYPES, FIELD_TYPE_CATEGORIES, getAllCategories } from '@/constants/formFieldTypes';
import { db } from '@/lib/firebase';
import { collection, addDoc, serverTimestamp } from 'firebase/firestore';

// Define the wizard steps
const steps = [
  'Form Purpose',
  'Content Requirements',
  'Format & Structure',
  'Branding & Design',
  'Distribution',
  'Review & Generate'
];

// Form purpose options
const formPurposeOptions = [
  { value: 'attendance', label: 'Attendance Tracking' },
  { value: 'onboarding', label: 'Onboarding Process' },
  { value: 'assessment', label: 'Assessment or Evaluation' },
  { value: 'survey', label: 'Survey or Feedback' },
  { value: 'referral', label: 'Referral Form' },
  { value: 'consent', label: 'Consent or Authorization' },
  { value: 'application', label: 'Application Form' },
  { value: 'other', label: 'Other' }
];

// Use field types from constants
const fieldTypeOptions = FIELD_TYPES;

// Mock function for AI analysis (to be replaced with actual API call)
const performAiAnalysis = async (wizardData: any) => {
  // Simulate API call delay
  await new Promise(resolve => setTimeout(resolve, 2000));
  
  // This would be replaced with actual API call to CHWOne AI Analyst
  return {
    success: true,
    formStructure: {
      title: wizardData.formName || 'Generated Form',
      description: wizardData.formDescription || 'Form generated by CHWOne AI Analyst',
      sections: [
        {
          id: 'section-1',
          title: 'Basic Information',
          fields: [
            {
              id: 'field-1',
              type: 'text',
              label: 'Full Name',
              required: true
            },
            {
              id: 'field-2',
              type: 'email',
              label: 'Email Address',
              required: true
            }
          ]
        },
        {
          id: 'section-2',
          title: 'Additional Information',
          fields: [
            {
              id: 'field-3',
              type: 'textarea',
              label: 'Comments',
              required: false
            }
          ]
        }
      ]
    },
    recommendations: [
      'Consider adding a date field to track when the form was completed',
      'For attendance tracking, a signature field would be beneficial',
      'Adding a section for feedback would improve data collection'
    ]
  };
};

// Generate form suggestions based on title
const generateTitleSuggestions = (title: string): string[] => {
  const suggestions: string[] = [];
  const lowerTitle = title.toLowerCase();
  
  // Analyze title for keywords and suggest relevant fields
  if (lowerTitle.includes('contact') || lowerTitle.includes('registration')) {
    suggestions.push('Include name, email, and phone number fields');
    suggestions.push('Add address fields for complete contact information');
  }
  
  if (lowerTitle.includes('survey') || lowerTitle.includes('feedback')) {
    suggestions.push('Use rating scales for satisfaction questions');
    suggestions.push('Include open-ended text areas for detailed feedback');
    suggestions.push('Add multiple choice questions for quick responses');
  }
  
  if (lowerTitle.includes('application') || lowerTitle.includes('enrollment')) {
    suggestions.push('Include personal information section');
    suggestions.push('Add document upload fields for required files');
    suggestions.push('Include consent and agreement checkboxes');
  }
  
  if (lowerTitle.includes('assessment') || lowerTitle.includes('evaluation')) {
    suggestions.push('Use structured rating fields for consistent evaluation');
    suggestions.push('Include comment sections for qualitative feedback');
    suggestions.push('Add date fields to track assessment timeline');
  }
  
  if (lowerTitle.includes('event') || lowerTitle.includes('attendance')) {
    suggestions.push('Include date and time selection fields');
    suggestions.push('Add attendance confirmation checkbox');
    suggestions.push('Include dietary restrictions or special needs fields');
  }
  
  if (lowerTitle.includes('health') || lowerTitle.includes('medical')) {
    suggestions.push('Include medical history checkboxes');
    suggestions.push('Add emergency contact information fields');
    suggestions.push('Include consent for treatment checkbox');
  }
  
  // Generic suggestions if no specific keywords found
  if (suggestions.length === 0) {
    suggestions.push('Start with basic information fields (name, email)');
    suggestions.push('Organize related fields into logical sections');
    suggestions.push('Mark required fields clearly');
  }
  
  return suggestions;
};

// Function to actually generate and save form to Firestore
const generateForm = async (formStructure: any, userId: string) => {
  console.log('[generateForm] Starting form generation...');
  console.log('[generateForm] Form structure:', formStructure);
  console.log('[generateForm] User ID:', userId);
  
  try {
    // Flatten the form structure into fields array
    const flattenedFields: any[] = [];
    
    if (formStructure.sections) {
      console.log('[generateForm] Processing sections:', formStructure.sections.length);
      formStructure.sections.forEach((section: any) => {
        section.fields.forEach((field: any) => {
          const fieldData: any = {
            id: field.id,
            name: field.id,
            label: field.label,
            type: field.type,
            required: field.required || false
          };
          
          // Only add optional fields if they have values
          if (field.placeholder) {
            fieldData.placeholder = field.placeholder;
          }
          if (field.options && field.options.length > 0) {
            fieldData.options = field.options.map((opt: any) => ({
              value: typeof opt === 'string' ? opt : opt.value,
              label: typeof opt === 'string' ? opt : opt.label
            }));
          }
          if (field.validation) {
            fieldData.validation = field.validation;
          }
          
          flattenedFields.push(fieldData);
        });
      });
    }
    
    console.log('[generateForm] Flattened fields:', flattenedFields.length, 'fields');
    console.log('[generateForm] Fields:', flattenedFields);
    
    // Create form document
    const formData = {
      title: formStructure.title,
      description: formStructure.description,
      category: 'other',
      tags: ['ai-generated'],
      fields: flattenedFields,
      userId: userId,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
      status: 'draft',
      isTemplate: false,
      settings: {
        confirmationMessage: 'Thank you for your submission!',
        allowAnonymous: true
      },
      metadata: {
        generatedBy: 'CHWOne AI Form Wizard',
        generatedAt: new Date().toISOString()
      }
    };
    
    // Save to Firestore
    console.log('[generateForm] Saving form to Firestore...');
    console.log('[generateForm] Form data:', formData);
    const formsRef = collection(db, 'forms');
    const formDocRef = await addDoc(formsRef, formData);
    console.log('[generateForm] Form saved! ID:', formDocRef.id);
    
    // Create associated dataset
    const datasetData = {
      name: `${formStructure.title} - Responses`,
      description: `Response data for ${formStructure.title}`,
      formId: formDocRef.id,
      userId: userId,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
      format: 'json',
      size: 0,
      recordCount: 0,
      rowCount: 0,
      fields: flattenedFields.map((f: any) => ({
        name: f.name,
        type: f.type,
        label: f.label
      })),
      records: [],
      metadata: {
        source: 'CHWOne AI Form Wizard',
        createdAt: new Date().toISOString()
      }
    };
    
    console.log('[generateForm] Creating dataset...');
    const datasetsRef = collection(db, 'datasets');
    const datasetDocRef = await addDoc(datasetsRef, datasetData);
    console.log('[generateForm] Dataset created! ID:', datasetDocRef.id);
    
    // Update form with dataset reference
    console.log('[generateForm] Linking dataset to form...');
    const { doc: docRef, updateDoc } = await import('firebase/firestore');
    const formRef = docRef(db, 'forms', formDocRef.id);
    await updateDoc(formRef, {
      datasetId: datasetDocRef.id
    });
    console.log('[generateForm] Form updated with dataset reference');
    
    const result = {
      success: true,
      formId: formDocRef.id,
      datasetId: datasetDocRef.id,
      message: 'Form generated and saved successfully'
    };
    console.log('[generateForm] Returning success result:', result);
    return result;
  } catch (error) {
    console.error('[generateForm] Error generating form:', error);
    const errorResult = {
      success: false,
      formId: null,
      message: `Failed to generate form: ${error instanceof Error ? error.message : 'Unknown error'}`
    };
    console.error('[generateForm] Returning error result:', errorResult);
    return errorResult;
  }
};

interface BmadFormWizardProps {
  onComplete?: (formId: string) => void;
  initialCategory?: string;
}

export default function BmadFormWizard({ onComplete, initialCategory }: BmadFormWizardProps) {
  const { currentUser } = useAuth();
  const [activeStep, setActiveStep] = useState(0);
  const [loading, setLoading] = useState(false);
  const [analyzing, setAnalyzing] = useState(false);
  const [generating, setGenerating] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [formPreview, setFormPreview] = useState<any>(null);
  const [recommendations, setRecommendations] = useState<string[]>([]);
  const [generatedFormId, setGeneratedFormId] = useState<string | null>(null);
  const [titleSuggestions, setTitleSuggestions] = useState<string[]>([]);
  
  // Wizard form state
  const [wizardData, setWizardData] = useState({
    // Step 1: Form Purpose
    formCategory: initialCategory || '',
    formName: '',
    formDescription: '',
    targetAudience: '',
    
    // Step 2: Content Requirements
    essentialFields: '',
    optionalFields: '',
    conditionalLogic: false,
    validationRules: false,
    
    // Step 3: Format & Structure
    formLayout: 'standard',
    sectionOrganization: 'logical',
    mobileOptimization: true,
    accessibilityRequirements: true,
    
    // Step 4: Branding & Design
    includeLogo: false,
    colorScheme: 'default',
    headerFooter: true,
    fontPreference: 'default',
    
    // Step 5: Distribution & Collection
    deliveryMethod: 'email',
    responseCollection: 'database',
    notificationSettings: false,
    submissionDeadline: false
  });
  
  // Handle form input changes
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value, type } = e.target;
    const checked = (e.target as HTMLInputElement).checked;

    setWizardData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
    
    // Generate suggestions when form name changes
    if (name === 'formName' && value.length > 3) {
      const suggestions = generateTitleSuggestions(value);
      setTitleSuggestions(suggestions);
    }
  };

  const handleSelectChange = (e: SelectChangeEvent<string>) => {
    const { name, value } = e.target;
    setWizardData(prev => ({
      ...prev,
      [name as string]: value
    }));
  };

  const handleRadioGroupChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setWizardData(prev => ({
      ...prev,
      [name]: value
    }));
  };
  
  // Handle step navigation
  const handleNext = () => {
    if (activeStep === steps.length - 1) {
      handleGenerateForm();
    } else {
      setActiveStep(prevStep => prevStep + 1);
    }
  };
  
  const handleBack = () => {
    setActiveStep(prevStep => prevStep - 1);
  };
  
  // Handle form preview generation
  const handlePreviewForm = async () => {
    setAnalyzing(true);
    setError(null);
    
    try {
      const result = await performAiAnalysis(wizardData);
      if (result.success) {
        setFormPreview(result.formStructure);
        setRecommendations(result.recommendations);
      } else {
        setError('Failed to generate form preview. Please try again.');
      }
    } catch (err) {
      setError('An error occurred during analysis. Please try again.');
      console.error(err);
    } finally {
      setAnalyzing(false);
    }
  };
  
  // Handle final form generation
  const handleGenerateForm = async () => {
    console.log('[AI Wizard] Starting form generation...');
    console.log('[AI Wizard] Form preview:', formPreview);
    console.log('[AI Wizard] Current user:', currentUser?.uid);
    
    if (!formPreview) {
      setError('Please generate a form preview first.');
      console.error('[AI Wizard] No form preview available');
      return;
    }
    
    if (!currentUser) {
      setError('You must be logged in to generate forms.');
      console.error('[AI Wizard] No current user');
      return;
    }
    
    setGenerating(true);
    setError(null);
    
    try {
      console.log('[AI Wizard] Calling generateForm...');
      const result = await generateForm(formPreview, currentUser.uid);
      console.log('[AI Wizard] Generation result:', result);
      
      if (result.success && result.formId) {
        console.log('[AI Wizard] Form generated successfully! ID:', result.formId);
        setGeneratedFormId(result.formId);
        if (onComplete) {
          console.log('[AI Wizard] Calling onComplete callback...');
          onComplete(result.formId);
        } else {
          console.warn('[AI Wizard] No onComplete callback provided');
        }
      } else {
        console.error('[AI Wizard] Form generation failed:', result.message);
        setError(result.message || 'Failed to generate form. Please try again.');
      }
    } catch (err) {
      console.error('[AI Wizard] Exception during form generation:', err);
      setError('An error occurred during form generation. Please try again.');
    } finally {
      setGenerating(false);
      console.log('[AI Wizard] Form generation complete');
    }
  };
  
  // Effect to generate preview when reaching the final step
  useEffect(() => {
    if (activeStep === steps.length - 1 && !formPreview && !analyzing) {
      handlePreviewForm();
    }
  }, [activeStep, formPreview, analyzing]);
  
  // Render step content based on active step
  const getStepContent = (step: number) => {
    switch (step) {
      case 0: // Form Purpose
        return (
          <Box>
            <Typography variant="h6" gutterBottom>
              What kind of form would you like to create?
            </Typography>
            
            <FormControl fullWidth margin="normal">
              <FormLabel id="form-category-label">Form Category</FormLabel>
              <RadioGroup
                aria-labelledby="form-category-label"
                name="formCategory"
                value={wizardData.formCategory}
                onChange={handleInputChange}
              >
                <Grid container spacing={2}>
                  {formPurposeOptions.map(option => (
                    <Grid item xs={6} key={option.value}>
                      <FormControlLabel 
                        value={option.value} 
                        control={<Radio />} 
                        label={option.label} 
                      />
                    </Grid>
                  ))}
                </Grid>
              </RadioGroup>
            </FormControl>
            
            <TextField
              fullWidth
              margin="normal"
              label="Form Name"
              name="formName"
              value={wizardData.formName}
              onChange={handleInputChange}
              required
              helperText="Enter a descriptive name to get AI-powered suggestions"
            />
            
            {titleSuggestions.length > 0 && (
              <Alert 
                severity="info" 
                icon={<LightbulbIcon />}
                sx={{ mt: 2, mb: 2 }}
              >
                <Typography variant="subtitle2" gutterBottom>
                  <strong>AI Suggestions based on your form title:</strong>
                </Typography>
                <List dense>
                  {titleSuggestions.map((suggestion, index) => (
                    <ListItem key={index} sx={{ py: 0.5 }}>
                      <ListItemText 
                        primary={`â€¢ ${suggestion}`}
                        primaryTypographyProps={{ variant: 'body2' }}
                      />
                    </ListItem>
                  ))}
                </List>
              </Alert>
            )}
            
            <TextField
              fullWidth
              margin="normal"
              label="Form Description"
              name="formDescription"
              value={wizardData.formDescription}
              onChange={handleInputChange}
              multiline
              rows={3}
            />
            
            <TextField
              fullWidth
              margin="normal"
              label="Target Audience"
              name="targetAudience"
              value={wizardData.targetAudience}
              onChange={handleInputChange}
              placeholder="Who will be filling out this form?"
            />
          </Box>
        );
        
      case 1: // Content Requirements
        return (
          <Box>
            <Typography variant="h6" gutterBottom>
              What information do you need to collect?
            </Typography>
            
            <TextField
              fullWidth
              margin="normal"
              label="Essential Information (Required Fields)"
              name="essentialFields"
              value={wizardData.essentialFields}
              onChange={handleInputChange}
              multiline
              rows={4}
              placeholder="List the essential information you need to collect, one item per line"
              required
            />
            
            <TextField
              fullWidth
              margin="normal"
              label="Optional Information (Optional Fields)"
              name="optionalFields"
              value={wizardData.optionalFields}
              onChange={handleInputChange}
              multiline
              rows={3}
              placeholder="List any optional information you'd like to collect, one item per line"
            />
            
            <FormControlLabel
              control={
                <Checkbox
                  checked={wizardData.conditionalLogic}
                  onChange={handleInputChange}
                  name="conditionalLogic"
                />
              }
              label="Include conditional logic (show/hide fields based on responses)"
            />
            
            <FormControlLabel
              control={
                <Checkbox
                  checked={wizardData.validationRules}
                  onChange={handleInputChange}
                  name="validationRules"
                />
              }
              label="Include validation rules (e.g., email format, required fields)"
            />
          </Box>
        );
        
      case 2: // Format & Structure
        return (
          <Box>
            <Typography variant="h6" gutterBottom>
              How should the form be structured?
            </Typography>
            
            <FormControl fullWidth margin="normal">
              <InputLabel id="form-layout-label">Form Layout</InputLabel>
              <Select
                labelId="form-layout-label"
                name="formLayout"
                value={wizardData.formLayout}
                onChange={handleSelectChange}
                label="Form Layout"
              >
                <MenuItem value="standard">Standard (Single Page)</MenuItem>
                <MenuItem value="wizard">Wizard (Step by Step)</MenuItem>
                <MenuItem value="tabs">Tabbed (Sections as Tabs)</MenuItem>
                <MenuItem value="accordion">Accordion (Expandable Sections)</MenuItem>
              </Select>
            </FormControl>
            
            <FormControl fullWidth margin="normal">
              <InputLabel id="section-organization-label">Section Organization</InputLabel>
              <Select
                labelId="section-organization-label"
                name="sectionOrganization"
                value={wizardData.sectionOrganization}
                onChange={handleSelectChange}
                label="Section Organization"
              >
                <MenuItem value="logical">Logical Grouping</MenuItem>
                <MenuItem value="chronological">Chronological Order</MenuItem>
                <MenuItem value="priority">Priority Based</MenuItem>
                <MenuItem value="complexity">Simple to Complex</MenuItem>
              </Select>
            </FormControl>
            
            <FormControlLabel
              control={
                <Checkbox
                  checked={wizardData.mobileOptimization}
                  onChange={handleInputChange}
                  name="mobileOptimization"
                />
              }
              label="Optimize for mobile devices"
            />
            
            <FormControlLabel
              control={
                <Checkbox
                  checked={wizardData.accessibilityRequirements}
                  onChange={handleInputChange}
                  name="accessibilityRequirements"
                />
              }
              label="Include accessibility features (screen reader support, keyboard navigation)"
            />
          </Box>
        );
        
      case 3: // Branding & Design
        return (
          <Box>
            <Typography variant="h6" gutterBottom>
              How should the form look?
            </Typography>
            
            <FormControlLabel
              control={
                <Checkbox
                  checked={wizardData.includeLogo}
                  onChange={handleInputChange}
                  name="includeLogo"
                />
              }
              label="Include organization logo"
            />
            
            <FormControl fullWidth margin="normal">
              <InputLabel id="color-scheme-label">Color Scheme</InputLabel>
              <Select
                labelId="color-scheme-label"
                name="colorScheme"
                value={wizardData.colorScheme}
                onChange={handleSelectChange}
                label="Color Scheme"
              >
                <MenuItem value="default">Default (Platform Colors)</MenuItem>
                <MenuItem value="blue">Blue Theme</MenuItem>
                <MenuItem value="green">Green Theme</MenuItem>
                <MenuItem value="purple">Purple Theme</MenuItem>
                <MenuItem value="neutral">Neutral/Grayscale</MenuItem>
              </Select>
            </FormControl>
            
            <FormControlLabel
              control={
                <Checkbox
                  checked={wizardData.headerFooter}
                  onChange={handleInputChange}
                  name="headerFooter"
                />
              }
              label="Include header and footer"
            />
            
            <FormControl fullWidth margin="normal">
              <InputLabel id="font-preference-label">Font Preference</InputLabel>
              <Select
                labelId="font-preference-label"
                name="fontPreference"
                value={wizardData.fontPreference}
                onChange={handleSelectChange}
                label="Font Preference"
              >
                <MenuItem value="default">Default (System Fonts)</MenuItem>
                <MenuItem value="serif">Serif (Traditional)</MenuItem>
                <MenuItem value="sans-serif">Sans-serif (Modern)</MenuItem>
                <MenuItem value="accessible">Highly Accessible</MenuItem>
              </Select>
            </FormControl>
          </Box>
        );
        
      case 4: // Distribution & Collection
        return (
          <Box>
            <Typography variant="h6" gutterBottom>
              How will the form be distributed and responses collected?
            </Typography>
            
            <FormControl fullWidth margin="normal">
              <InputLabel id="delivery-method-label">Delivery Method</InputLabel>
              <Select
                labelId="delivery-method-label"
                name="deliveryMethod"
                value={wizardData.deliveryMethod}
                onChange={handleSelectChange}
                label="Delivery Method"
              >
                <MenuItem value="email">Email Link</MenuItem>
                <MenuItem value="qr">QR Code</MenuItem>
                <MenuItem value="embedded">Embedded on Website</MenuItem>
                <MenuItem value="direct">Direct Access in Platform</MenuItem>
                <MenuItem value="print">Print/Paper Form</MenuItem>
              </Select>
            </FormControl>
            
            <FormControl fullWidth margin="normal">
              <InputLabel id="response-collection-label">Response Collection</InputLabel>
              <Select
                labelId="response-collection-label"
                name="responseCollection"
                value={wizardData.responseCollection}
                onChange={handleSelectChange}
                label="Response Collection"
              >
                <MenuItem value="database">Store in Database</MenuItem>
                <MenuItem value="email">Email Notifications</MenuItem>
                <MenuItem value="export">Export to Spreadsheet</MenuItem>
                <MenuItem value="api">Send to External System via API</MenuItem>
              </Select>
            </FormControl>
            
            <FormControlLabel
              control={
                <Checkbox
                  checked={wizardData.notificationSettings}
                  onChange={handleInputChange}
                  name="notificationSettings"
                />
              }
              label="Send notifications on form submission"
            />
            
            <FormControlLabel
              control={
                <Checkbox
                  checked={wizardData.submissionDeadline}
                  onChange={handleInputChange}
                  name="submissionDeadline"
                />
              }
              label="Set submission deadline"
            />
          </Box>
        );
        
      case 5: // Review & Generate
        return (
          <Box>
            <Typography variant="h6" gutterBottom>
              Review and Generate Form
            </Typography>
            
            {analyzing ? (
              <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', my: 4 }}>
                <CircularProgress />
                <Typography variant="body1" sx={{ mt: 2 }}>
                  BMAD AI Analyst is analyzing your requirements...
                </Typography>
              </Box>
            ) : formPreview ? (
              <Box>
                <Alert severity="success" sx={{ mb: 2 }}>
                  Form preview generated successfully!
                </Alert>
                
                <Paper variant="outlined" sx={{ p: 2, mb: 3 }}>
                  <Typography variant="h6">{formPreview.title}</Typography>
                  <Typography variant="body2" color="text.secondary" gutterBottom>
                    {formPreview.description}
                  </Typography>
                  
                  <Divider sx={{ my: 2 }} />
                  
                  {formPreview.sections.map((section: any, index: number) => (
                    <Box key={section.id} sx={{ mb: 3 }}>
                      <Typography variant="subtitle1" fontWeight="bold">
                        {section.title}
                      </Typography>
                      
                      {section.fields.map((field: any) => (
                        <Box key={field.id} sx={{ mb: 2 }}>
                          <Typography variant="body2">
                            {field.label} {field.required && <span style={{ color: 'red' }}>*</span>}
                          </Typography>
                          <Typography variant="caption" color="text.secondary">
                            Field Type: {field.type}
                          </Typography>
                        </Box>
                      ))}
                    </Box>
                  ))}
                </Paper>
                
                <Typography variant="subtitle1" gutterBottom>
                  AI Recommendations:
                </Typography>
                
                <Box sx={{ mb: 3 }}>
                  {recommendations.map((rec, index) => (
                    <Alert key={index} severity="info" sx={{ mb: 1 }}>
                      {rec}
                    </Alert>
                  ))}
                </Box>
                
                {generating ? (
                  <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', my: 2 }}>
                    <CircularProgress />
                    <Typography variant="body1" sx={{ mt: 2 }}>
                      Generating your form...
                    </Typography>
                  </Box>
                ) : generatedFormId ? (
                  <Alert 
                    severity="success" 
                    icon={<CheckIcon fontSize="inherit" />}
                    sx={{ mb: 2 }}
                  >
                    Form generated successfully! Form ID: {generatedFormId}
                  </Alert>
                ) : null}
              </Box>
            ) : (
              <Box sx={{ display: 'flex', justifyContent: 'center', my: 4 }}>
                <Button
                  variant="contained"
                  color="primary"
                  onClick={handlePreviewForm}
                  startIcon={<RefreshIcon />}
                >
                  Generate Form Preview
                </Button>
              </Box>
            )}
          </Box>
        );
        
      default:
        return 'Unknown step';
    }
  };
  
  // Check if the current step is complete
  const isStepComplete = (step: number) => {
    switch (step) {
      case 0: // Form Purpose
        return !!wizardData.formCategory && !!wizardData.formName;
      case 1: // Content Requirements
        return !!wizardData.essentialFields;
      case 2: // Format & Structure
        return true; // All fields have defaults
      case 3: // Branding & Design
        return true; // All fields have defaults
      case 4: // Distribution & Collection
        return true; // All fields have defaults
      case 5: // Review & Generate
        return !!formPreview;
      default:
        return false;
    }
  };
  
  return (
    <Box sx={{ width: '100%', p: 2 }}>
      <Paper sx={{ p: 3, mb: 4 }}>
        <Typography variant="h5" gutterBottom align="center">
          CHWOne AI Form Wizard
        </Typography>
        
        <Stepper activeStep={activeStep} alternativeLabel sx={{ mb: 4 }}>
          {steps.map((label, index) => (
            <Step key={label} completed={index < activeStep}>
              <StepLabel>{label}</StepLabel>
            </Step>
          ))}
        </Stepper>
        
        {error && (
          <Alert severity="error" sx={{ mb: 3 }} onClose={() => setError(null)}>
            {error}
          </Alert>
        )}
        
        <Box sx={{ mb: 4 }}>
          {getStepContent(activeStep)}
        </Box>
        
        <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
          <Button
            disabled={activeStep === 0}
            onClick={handleBack}
            startIcon={<ArrowBackIcon />}
          >
            Back
          </Button>
          
          <Button
            variant="contained"
            color="primary"
            onClick={handleNext}
            endIcon={activeStep === steps.length - 1 ? <DescriptionIcon /> : <ArrowForwardIcon />}
            disabled={!isStepComplete(activeStep) || analyzing || generating}
          >
            {activeStep === steps.length - 1 ? 'Generate Form' : 'Next'}
          </Button>
        </Box>
      </Paper>
    </Box>
  );
}
