'use client';

import React, { useState, useEffect } from 'react';
import {
  Box,
  Stepper,
  Step,
  StepLabel,
  Button,
  Typography,
  Paper,
  TextField,
  FormControl,
  FormLabel,
  RadioGroup,
  FormControlLabel,
  Radio,
  Checkbox,
  Select,
  MenuItem,
  InputLabel,
  CircularProgress,
  Divider,
  Alert,
  Grid
} from '@mui/material';
import { 
  ArrowForward as ArrowForwardIcon, 
  ArrowBack as ArrowBackIcon,
  Save as SaveIcon,
  Refresh as RefreshIcon,
  Description as DescriptionIcon,
  Check as CheckIcon
} from '@mui/icons-material';
import { useAuth } from '@/contexts/AuthContext';

// Define the wizard steps
const steps = [
  'Form Purpose',
  'Content Requirements',
  'Format & Structure',
  'Branding & Design',
  'Distribution',
  'Review & Generate'
];

// Form purpose options
const formPurposeOptions = [
  { value: 'attendance', label: 'Attendance Tracking' },
  { value: 'onboarding', label: 'Onboarding Process' },
  { value: 'assessment', label: 'Assessment or Evaluation' },
  { value: 'survey', label: 'Survey or Feedback' },
  { value: 'referral', label: 'Referral Form' },
  { value: 'consent', label: 'Consent or Authorization' },
  { value: 'application', label: 'Application Form' },
  { value: 'other', label: 'Other' }
];

// Field type options
const fieldTypeOptions = [
  { value: 'text', label: 'Text Input' },
  { value: 'textarea', label: 'Multi-line Text' },
  { value: 'number', label: 'Number' },
  { value: 'date', label: 'Date' },
  { value: 'time', label: 'Time' },
  { value: 'select', label: 'Dropdown Select' },
  { value: 'radio', label: 'Radio Buttons' },
  { value: 'checkbox', label: 'Checkboxes' },
  { value: 'file', label: 'File Upload' },
  { value: 'signature', label: 'Signature' },
  { value: 'table', label: 'Table/Grid' }
];

// Mock function for AI analysis (to be replaced with actual API call)
const performAiAnalysis = async (wizardData: any) => {
  // Simulate API call delay
  await new Promise(resolve => setTimeout(resolve, 2000));
  
  // This would be replaced with actual API call to BMAD AI Analyst
  return {
    success: true,
    formStructure: {
      title: wizardData.formName || 'Generated Form',
      description: wizardData.formDescription || 'Form generated by BMAD AI Analyst',
      sections: [
        {
          id: 'section-1',
          title: 'Basic Information',
          fields: [
            {
              id: 'field-1',
              type: 'text',
              label: 'Full Name',
              required: true
            },
            {
              id: 'field-2',
              type: 'email',
              label: 'Email Address',
              required: true
            }
          ]
        },
        {
          id: 'section-2',
          title: 'Additional Information',
          fields: [
            {
              id: 'field-3',
              type: 'textarea',
              label: 'Comments',
              required: false
            }
          ]
        }
      ]
    },
    recommendations: [
      'Consider adding a date field to track when the form was completed',
      'For attendance tracking, a signature field would be beneficial',
      'Adding a section for feedback would improve data collection'
    ]
  };
};

// Mock function for form generation (to be replaced with actual API call)
const generateForm = async (formStructure: any) => {
  // Simulate API call delay
  await new Promise(resolve => setTimeout(resolve, 3000));
  
  // This would be replaced with actual form generation
  return {
    success: true,
    formId: 'form-' + Math.random().toString(36).substr(2, 9),
    message: 'Form generated successfully'
  };
};

interface BmadFormWizardProps {
  onComplete?: (formId: string) => void;
  initialCategory?: string;
}

export default function BmadFormWizard({ onComplete, initialCategory }: BmadFormWizardProps) {
  const { currentUser } = useAuth();
  const [activeStep, setActiveStep] = useState(0);
  const [loading, setLoading] = useState(false);
  const [analyzing, setAnalyzing] = useState(false);
  const [generating, setGenerating] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [formPreview, setFormPreview] = useState<any>(null);
  const [recommendations, setRecommendations] = useState<string[]>([]);
  const [generatedFormId, setGeneratedFormId] = useState<string | null>(null);
  
  // Wizard form state
  const [wizardData, setWizardData] = useState({
    // Step 1: Form Purpose
    formCategory: initialCategory || '',
    formName: '',
    formDescription: '',
    targetAudience: '',
    
    // Step 2: Content Requirements
    essentialFields: '',
    optionalFields: '',
    conditionalLogic: false,
    validationRules: false,
    
    // Step 3: Format & Structure
    formLayout: 'standard',
    sectionOrganization: 'logical',
    mobileOptimization: true,
    accessibilityRequirements: true,
    
    // Step 4: Branding & Design
    includeLogo: false,
    colorScheme: 'default',
    headerFooter: true,
    fontPreference: 'default',
    
    // Step 5: Distribution & Collection
    deliveryMethod: 'email',
    responseCollection: 'database',
    notificationSettings: false,
    submissionDeadline: false
  });
  
  // Handle form input changes
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | { name?: string; value: unknown }>) => {
    const { name, value, type, checked } = e.target as HTMLInputElement;
    
    setWizardData(prev => ({
      ...prev,
      [name as string]: type === 'checkbox' ? checked : value
    }));
  };
  
  // Handle step navigation
  const handleNext = () => {
    if (activeStep === steps.length - 1) {
      handleGenerateForm();
    } else {
      setActiveStep(prevStep => prevStep + 1);
    }
  };
  
  const handleBack = () => {
    setActiveStep(prevStep => prevStep - 1);
  };
  
  // Handle form preview generation
  const handlePreviewForm = async () => {
    setAnalyzing(true);
    setError(null);
    
    try {
      const result = await performAiAnalysis(wizardData);
      if (result.success) {
        setFormPreview(result.formStructure);
        setRecommendations(result.recommendations);
      } else {
        setError('Failed to generate form preview. Please try again.');
      }
    } catch (err) {
      setError('An error occurred during analysis. Please try again.');
      console.error(err);
    } finally {
      setAnalyzing(false);
    }
  };
  
  // Handle final form generation
  const handleGenerateForm = async () => {
    if (!formPreview) {
      setError('Please generate a form preview first.');
      return;
    }
    
    setGenerating(true);
    setError(null);
    
    try {
      const result = await generateForm(formPreview);
      if (result.success) {
        setGeneratedFormId(result.formId);
        if (onComplete) {
          onComplete(result.formId);
        }
      } else {
        setError('Failed to generate form. Please try again.');
      }
    } catch (err) {
      setError('An error occurred during form generation. Please try again.');
      console.error(err);
    } finally {
      setGenerating(false);
    }
  };
  
  // Effect to generate preview when reaching the final step
  useEffect(() => {
    if (activeStep === steps.length - 1 && !formPreview && !analyzing) {
      handlePreviewForm();
    }
  }, [activeStep, formPreview, analyzing]);
  
  // Render step content based on active step
  const getStepContent = (step: number) => {
    switch (step) {
      case 0: // Form Purpose
        return (
          <Box>
            <Typography variant="h6" gutterBottom>
              What kind of form would you like to create?
            </Typography>
            
            <FormControl fullWidth margin="normal">
              <FormLabel id="form-category-label">Form Category</FormLabel>
              <RadioGroup
                aria-labelledby="form-category-label"
                name="formCategory"
                value={wizardData.formCategory}
                onChange={handleInputChange}
              >
                <Grid container spacing={2}>
                  {formPurposeOptions.map(option => (
                    <Grid item xs={6} key={option.value}>
                      <FormControlLabel 
                        value={option.value} 
                        control={<Radio />} 
                        label={option.label} 
                      />
                    </Grid>
                  ))}
                </Grid>
              </RadioGroup>
            </FormControl>
            
            <TextField
              fullWidth
              margin="normal"
              label="Form Name"
              name="formName"
              value={wizardData.formName}
              onChange={handleInputChange}
              required
            />
            
            <TextField
              fullWidth
              margin="normal"
              label="Form Description"
              name="formDescription"
              value={wizardData.formDescription}
              onChange={handleInputChange}
              multiline
              rows={3}
            />
            
            <TextField
              fullWidth
              margin="normal"
              label="Target Audience"
              name="targetAudience"
              value={wizardData.targetAudience}
              onChange={handleInputChange}
              placeholder="Who will be filling out this form?"
            />
          </Box>
        );
        
      case 1: // Content Requirements
        return (
          <Box>
            <Typography variant="h6" gutterBottom>
              What information do you need to collect?
            </Typography>
            
            <TextField
              fullWidth
              margin="normal"
              label="Essential Information (Required Fields)"
              name="essentialFields"
              value={wizardData.essentialFields}
              onChange={handleInputChange}
              multiline
              rows={4}
              placeholder="List the essential information you need to collect, one item per line"
              required
            />
            
            <TextField
              fullWidth
              margin="normal"
              label="Optional Information (Optional Fields)"
              name="optionalFields"
              value={wizardData.optionalFields}
              onChange={handleInputChange}
              multiline
              rows={3}
              placeholder="List any optional information you'd like to collect, one item per line"
            />
            
            <FormControlLabel
              control={
                <Checkbox
                  checked={wizardData.conditionalLogic}
                  onChange={handleInputChange}
                  name="conditionalLogic"
                />
              }
              label="Include conditional logic (show/hide fields based on responses)"
            />
            
            <FormControlLabel
              control={
                <Checkbox
                  checked={wizardData.validationRules}
                  onChange={handleInputChange}
                  name="validationRules"
                />
              }
              label="Include validation rules (e.g., email format, required fields)"
            />
          </Box>
        );
        
      case 2: // Format & Structure
        return (
          <Box>
            <Typography variant="h6" gutterBottom>
              How should the form be structured?
            </Typography>
            
            <FormControl fullWidth margin="normal">
              <InputLabel id="form-layout-label">Form Layout</InputLabel>
              <Select
                labelId="form-layout-label"
                name="formLayout"
                value={wizardData.formLayout}
                onChange={handleInputChange}
                label="Form Layout"
              >
                <MenuItem value="standard">Standard (Single Page)</MenuItem>
                <MenuItem value="wizard">Wizard (Step by Step)</MenuItem>
                <MenuItem value="tabs">Tabbed (Sections as Tabs)</MenuItem>
                <MenuItem value="accordion">Accordion (Expandable Sections)</MenuItem>
              </Select>
            </FormControl>
            
            <FormControl fullWidth margin="normal">
              <InputLabel id="section-organization-label">Section Organization</InputLabel>
              <Select
                labelId="section-organization-label"
                name="sectionOrganization"
                value={wizardData.sectionOrganization}
                onChange={handleInputChange}
                label="Section Organization"
              >
                <MenuItem value="logical">Logical Grouping</MenuItem>
                <MenuItem value="chronological">Chronological Order</MenuItem>
                <MenuItem value="priority">Priority Based</MenuItem>
                <MenuItem value="complexity">Simple to Complex</MenuItem>
              </Select>
            </FormControl>
            
            <FormControlLabel
              control={
                <Checkbox
                  checked={wizardData.mobileOptimization}
                  onChange={handleInputChange}
                  name="mobileOptimization"
                />
              }
              label="Optimize for mobile devices"
            />
            
            <FormControlLabel
              control={
                <Checkbox
                  checked={wizardData.accessibilityRequirements}
                  onChange={handleInputChange}
                  name="accessibilityRequirements"
                />
              }
              label="Include accessibility features (screen reader support, keyboard navigation)"
            />
          </Box>
        );
        
      case 3: // Branding & Design
        return (
          <Box>
            <Typography variant="h6" gutterBottom>
              How should the form look?
            </Typography>
            
            <FormControlLabel
              control={
                <Checkbox
                  checked={wizardData.includeLogo}
                  onChange={handleInputChange}
                  name="includeLogo"
                />
              }
              label="Include organization logo"
            />
            
            <FormControl fullWidth margin="normal">
              <InputLabel id="color-scheme-label">Color Scheme</InputLabel>
              <Select
                labelId="color-scheme-label"
                name="colorScheme"
                value={wizardData.colorScheme}
                onChange={handleInputChange}
                label="Color Scheme"
              >
                <MenuItem value="default">Default (Platform Colors)</MenuItem>
                <MenuItem value="blue">Blue Theme</MenuItem>
                <MenuItem value="green">Green Theme</MenuItem>
                <MenuItem value="purple">Purple Theme</MenuItem>
                <MenuItem value="neutral">Neutral/Grayscale</MenuItem>
              </Select>
            </FormControl>
            
            <FormControlLabel
              control={
                <Checkbox
                  checked={wizardData.headerFooter}
                  onChange={handleInputChange}
                  name="headerFooter"
                />
              }
              label="Include header and footer"
            />
            
            <FormControl fullWidth margin="normal">
              <InputLabel id="font-preference-label">Font Preference</InputLabel>
              <Select
                labelId="font-preference-label"
                name="fontPreference"
                value={wizardData.fontPreference}
                onChange={handleInputChange}
                label="Font Preference"
              >
                <MenuItem value="default">Default (System Fonts)</MenuItem>
                <MenuItem value="serif">Serif (Traditional)</MenuItem>
                <MenuItem value="sans-serif">Sans-serif (Modern)</MenuItem>
                <MenuItem value="accessible">Highly Accessible</MenuItem>
              </Select>
            </FormControl>
          </Box>
        );
        
      case 4: // Distribution & Collection
        return (
          <Box>
            <Typography variant="h6" gutterBottom>
              How will the form be distributed and responses collected?
            </Typography>
            
            <FormControl fullWidth margin="normal">
              <InputLabel id="delivery-method-label">Delivery Method</InputLabel>
              <Select
                labelId="delivery-method-label"
                name="deliveryMethod"
                value={wizardData.deliveryMethod}
                onChange={handleInputChange}
                label="Delivery Method"
              >
                <MenuItem value="email">Email Link</MenuItem>
                <MenuItem value="qr">QR Code</MenuItem>
                <MenuItem value="embedded">Embedded on Website</MenuItem>
                <MenuItem value="direct">Direct Access in Platform</MenuItem>
                <MenuItem value="print">Print/Paper Form</MenuItem>
              </Select>
            </FormControl>
            
            <FormControl fullWidth margin="normal">
              <InputLabel id="response-collection-label">Response Collection</InputLabel>
              <Select
                labelId="response-collection-label"
                name="responseCollection"
                value={wizardData.responseCollection}
                onChange={handleInputChange}
                label="Response Collection"
              >
                <MenuItem value="database">Store in Database</MenuItem>
                <MenuItem value="email">Email Notifications</MenuItem>
                <MenuItem value="export">Export to Spreadsheet</MenuItem>
                <MenuItem value="api">Send to External System via API</MenuItem>
              </Select>
            </FormControl>
            
            <FormControlLabel
              control={
                <Checkbox
                  checked={wizardData.notificationSettings}
                  onChange={handleInputChange}
                  name="notificationSettings"
                />
              }
              label="Send notifications on form submission"
            />
            
            <FormControlLabel
              control={
                <Checkbox
                  checked={wizardData.submissionDeadline}
                  onChange={handleInputChange}
                  name="submissionDeadline"
                />
              }
              label="Set submission deadline"
            />
          </Box>
        );
        
      case 5: // Review & Generate
        return (
          <Box>
            <Typography variant="h6" gutterBottom>
              Review and Generate Form
            </Typography>
            
            {analyzing ? (
              <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', my: 4 }}>
                <CircularProgress />
                <Typography variant="body1" sx={{ mt: 2 }}>
                  BMAD AI Analyst is analyzing your requirements...
                </Typography>
              </Box>
            ) : formPreview ? (
              <Box>
                <Alert severity="success" sx={{ mb: 2 }}>
                  Form preview generated successfully!
                </Alert>
                
                <Paper variant="outlined" sx={{ p: 2, mb: 3 }}>
                  <Typography variant="h6">{formPreview.title}</Typography>
                  <Typography variant="body2" color="text.secondary" gutterBottom>
                    {formPreview.description}
                  </Typography>
                  
                  <Divider sx={{ my: 2 }} />
                  
                  {formPreview.sections.map((section: any, index: number) => (
                    <Box key={section.id} sx={{ mb: 3 }}>
                      <Typography variant="subtitle1" fontWeight="bold">
                        {section.title}
                      </Typography>
                      
                      {section.fields.map((field: any) => (
                        <Box key={field.id} sx={{ mb: 2 }}>
                          <Typography variant="body2">
                            {field.label} {field.required && <span style={{ color: 'red' }}>*</span>}
                          </Typography>
                          <Typography variant="caption" color="text.secondary">
                            Field Type: {field.type}
                          </Typography>
                        </Box>
                      ))}
                    </Box>
                  ))}
                </Paper>
                
                <Typography variant="subtitle1" gutterBottom>
                  AI Recommendations:
                </Typography>
                
                <Box sx={{ mb: 3 }}>
                  {recommendations.map((rec, index) => (
                    <Alert key={index} severity="info" sx={{ mb: 1 }}>
                      {rec}
                    </Alert>
                  ))}
                </Box>
                
                {generating ? (
                  <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', my: 2 }}>
                    <CircularProgress />
                    <Typography variant="body1" sx={{ mt: 2 }}>
                      Generating your form...
                    </Typography>
                  </Box>
                ) : generatedFormId ? (
                  <Alert 
                    severity="success" 
                    icon={<CheckIcon fontSize="inherit" />}
                    sx={{ mb: 2 }}
                  >
                    Form generated successfully! Form ID: {generatedFormId}
                  </Alert>
                ) : null}
              </Box>
            ) : (
              <Box sx={{ display: 'flex', justifyContent: 'center', my: 4 }}>
                <Button
                  variant="contained"
                  color="primary"
                  onClick={handlePreviewForm}
                  startIcon={<RefreshIcon />}
                >
                  Generate Form Preview
                </Button>
              </Box>
            )}
          </Box>
        );
        
      default:
        return 'Unknown step';
    }
  };
  
  // Check if the current step is complete
  const isStepComplete = (step: number) => {
    switch (step) {
      case 0: // Form Purpose
        return !!wizardData.formCategory && !!wizardData.formName;
      case 1: // Content Requirements
        return !!wizardData.essentialFields;
      case 2: // Format & Structure
        return true; // All fields have defaults
      case 3: // Branding & Design
        return true; // All fields have defaults
      case 4: // Distribution & Collection
        return true; // All fields have defaults
      case 5: // Review & Generate
        return !!formPreview;
      default:
        return false;
    }
  };
  
  return (
    <Box sx={{ width: '100%', p: 2 }}>
      <Paper sx={{ p: 3, mb: 4 }}>
        <Typography variant="h5" gutterBottom align="center">
          BMAD AI Form Wizard
        </Typography>
        
        <Stepper activeStep={activeStep} alternativeLabel sx={{ mb: 4 }}>
          {steps.map((label, index) => (
            <Step key={label} completed={index < activeStep}>
              <StepLabel>{label}</StepLabel>
            </Step>
          ))}
        </Stepper>
        
        {error && (
          <Alert severity="error" sx={{ mb: 3 }} onClose={() => setError(null)}>
            {error}
          </Alert>
        )}
        
        <Box sx={{ mb: 4 }}>
          {getStepContent(activeStep)}
        </Box>
        
        <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
          <Button
            disabled={activeStep === 0}
            onClick={handleBack}
            startIcon={<ArrowBackIcon />}
          >
            Back
          </Button>
          
          <Button
            variant="contained"
            color="primary"
            onClick={handleNext}
            endIcon={activeStep === steps.length - 1 ? <DescriptionIcon /> : <ArrowForwardIcon />}
            disabled={!isStepComplete(activeStep) || analyzing || generating}
          >
            {activeStep === steps.length - 1 ? 'Generate Form' : 'Next'}
          </Button>
        </Box>
      </Paper>
    </Box>
  );
}
