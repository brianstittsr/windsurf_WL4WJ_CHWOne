'use client';

import React, { createContext, useContext, useEffect, useState } from 'react';
import { log, logError, timeOperation } from '@/utils/logger';
import { 
  User,
  signInWithEmailAndPassword,
  createUserWithEmailAndPassword,
  signOut as firebaseSignOut,
  onAuthStateChanged,
  GoogleAuthProvider,
  signInWithPopup,
  sendPasswordResetEmail,
  updateProfile as firebaseUpdateProfile
} from 'firebase/auth';
import { auth, db, isValidConfig, isOfflineMode, mockUsers, toggleOfflineMode } from '@/lib/firebase/firebaseConfig';
import { safeGetDocument, safeUpdateDocument } from '@/lib/firebase/dataAccess';

// Firebase-only authentication
const AUTH_PROVIDER = 'firebase';

// Auto-login control (disabled for better login experience)
const DISABLE_AUTO_LOGIN = false;

// Define the shape of our auth context
interface AuthContextType {
  currentUser: User | null;
  userProfile: any | null;
  loading: boolean;
  error: string | null;
  signIn: (email: string, password: string) => Promise<User>;
  signInWithGoogle: () => Promise<User>;
  signUp: (email: string, password: string, displayName: string, role: string) => Promise<User>;
  signOut: () => Promise<void>;
  resetPassword: (email: string) => Promise<void>;
  updateProfile: (data: any) => Promise<void>;
  authProvider: string;
  firebaseError: boolean;
}

// Create the auth context
const AuthContext = createContext<AuthContextType | undefined>(undefined);

// Custom hook to use the auth context
export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}

// Provider component that wraps your app and makes auth available
export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [currentUser, setCurrentUser] = useState<User | null>(null);
  const [userProfile, setUserProfile] = useState<any | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [authProvider, setAuthProvider] = useState<string>('firebase');
  const [firebaseError, setFirebaseError] = useState(false);
  
  // Handle session timeout
  const sessionTimeout = 30 * 60 * 1000; // 30 minutes
  
  const setupSessionExpiration = () => {
    // Clear any existing timeout
    if (window.sessionTimeoutId) {
      clearTimeout(window.sessionTimeoutId);
    }
    
    // Set new timeout
    window.sessionTimeoutId = setTimeout(() => {
      console.log('Session expired');
      signOut();
    }, sessionTimeout);
    
    // Reset timeout on user activity
    const resetTimeout = () => {
      if (currentUser) {
        setupSessionExpiration();
      }
    };
    
    window.addEventListener('mousemove', resetTimeout);
    window.addEventListener('keypress', resetTimeout);
    
    return () => {
      window.removeEventListener('mousemove', resetTimeout);
      window.removeEventListener('keypress', resetTimeout);
    };
  };
  
  // RBAC DISABLED: User approval check bypassed
  const checkUserApproval = async (user: User) => {
    if (!user) return;
    
    try {
      // Try to get user data but don't enforce any restrictions
      const result = await safeGetDocument('users', user.uid);
      
      if (result && result.success && result.data) {
        // Set user profile with admin role and approved status
        const userData = {
          ...result.data,
          role: 'ADMIN', // Force admin role
          approved: true, // Force approved status
          permissions: ['*'] // Grant all permissions
        };
        setUserProfile(userData);
        console.log('RBAC DISABLED: User automatically approved with admin privileges');
      } else {
        // Create default admin profile if no user data exists
        const defaultProfile = {
          uid: user.uid,
          email: user.email,
          displayName: user.displayName || 'Admin User',
          role: 'ADMIN',
          approved: true,
          permissions: ['*'],
          createdAt: new Date().toISOString()
        };
        setUserProfile(defaultProfile);
        console.log('RBAC DISABLED: Created default admin profile');
      }
    } catch (error) {
      logError('AUTH', 'Error checking user data', error);
      
      // Create default admin profile on error
      const defaultProfile = {
        uid: user.uid,
        email: user.email,
        displayName: user.displayName || 'Admin User',
        role: 'ADMIN',
        approved: true,
        permissions: ['*'],
        createdAt: new Date().toISOString()
      };
      setUserProfile(defaultProfile);
      console.log('RBAC DISABLED: Created default admin profile after error');
    }
  };
  
  // Sign in with email and password
  const signIn = async (email: string, password: string) => {
    log('AUTH', 'Sign In Attempt');
    log('AUTH', 'Credentials', { email, passwordLength: password?.length });
    log('AUTH', 'Auth state before sign in', { 
      currentUser: currentUser?.email || null,
      loading,
      error,
      authProvider
    });
    setLoading(true);
    setError(null);
    
    return await timeOperation('AUTH', 'Sign In', async () => {
      try {
        // Check for offline mode first
        if (isOfflineMode) {
          log('AUTH', 'Using offline mode for sign in');
          const mockUser = mockUsers.find(user => user.email === email);
          
          if (mockUser && password === 'admin123') {
            // Store auth session for offline mode
            localStorage.setItem('authSession', JSON.stringify({
              uid: mockUser.uid,
              email: mockUser.email,
              displayName: mockUser.displayName,
              timestamp: new Date().toISOString()
            }));
            
            setAuthProvider('offline');
            return mockUser;
          } else {
            throw new Error('Invalid credentials for offline mode');
          }
        }
        
        // Use Firebase auth with retry logic
        if (!auth || !isValidConfig) {
          const errorMessage = 'Firebase authentication is not properly configured. Please check your environment variables.';
          logError('AUTH', 'Configuration error', errorMessage);
          setError(errorMessage);
          throw new Error(errorMessage);
        }
        
        // Retry logic for network issues
        const MAX_RETRIES = 3;
        let lastError = null;
        
        for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
          try {
            log('AUTH', 'Sign in attempt', { attempt: attempt + 1, maxRetries: MAX_RETRIES });
            const result = await signInWithEmailAndPassword(auth, email, password);
            setAuthProvider('firebase');
            return result.user;
          } catch (error: any) {
            lastError = error;
            
            // Only retry on network-related errors
            if (error.code === 'auth/network-request-failed' || 
                error.code === 'auth/timeout' ||
                error.message?.includes('network') ||
                error.message?.includes('timeout')) {
              
              log('AUTH', 'Network error during sign in, retrying...', { 
                attempt: attempt + 1, 
                maxRetries: MAX_RETRIES,
                errorCode: error.code
              });
              
              // Wait before retrying (exponential backoff)
              await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 500));
              
              // On last attempt, check if we should switch to offline mode
              if (attempt === MAX_RETRIES - 1) {
                log('AUTH', 'Maximum retries reached, checking for offline mode fallback');
                
                // If this is admin@example.com, try offline mode
                if (email === 'admin@example.com' && password === 'admin123') {
                  log('AUTH', 'Falling back to offline mode for admin user');
                  localStorage.setItem('forceOfflineMode', 'true');
                  
                  const mockUser = mockUsers.find(user => user.email === email);
                  if (mockUser) {
                    // Store auth session for offline mode
                    localStorage.setItem('authSession', JSON.stringify({
                      uid: mockUser.uid,
                      email: mockUser.email,
                      displayName: mockUser.displayName,
                      timestamp: new Date().toISOString()
                    }));
                    
                    setAuthProvider('offline');
                    return mockUser;
                  }
                }
              }
            } else {
              // Non-network error, don't retry
              break;
            }
          }
        }
        
        // If we got here, all retries failed
        logError('AUTH', 'Sign in error after retries', {
          message: lastError.message,
          code: lastError.code,
          stack: lastError.stack,
          timestamp: new Date().toISOString()
        });
        
        // Provide more user-friendly error messages
        let errorMessage = lastError.message || 'Failed to sign in';
        if (lastError.code === 'auth/network-request-failed') {
          errorMessage = 'Network connection error. Please check your internet connection and try again.';
        } else if (lastError.code === 'auth/wrong-password' || lastError.code === 'auth/user-not-found') {
          errorMessage = 'Invalid email or password. Please try again.';
        } else if (lastError.code === 'auth/too-many-requests') {
          errorMessage = 'Too many failed login attempts. Please try again later.';
        }
        
        setError(errorMessage);
        throw lastError;
      } catch (error: any) {
        if (!error.wasHandled) {
          logError('AUTH', 'Sign in error', {
            message: error.message,
            code: error.code,
            stack: error.stack,
            timestamp: new Date().toISOString()
          });
          setError(error.message || 'Failed to sign in');
        }
        throw error;
      } finally {
        setLoading(false);
      }
    });
  };
  
  // Sign in with Google
  const signInWithGoogle = async () => {
    setLoading(true);
    setError(null);
    
    return await timeOperation('AUTH', 'Google Sign In', async () => {
      try {
        const provider = new GoogleAuthProvider();
        const result = await signInWithPopup(auth, provider);
        setAuthProvider('firebase');
        return result.user;
      } catch (error: any) {
        logError('AUTH', 'Google sign in error', error);
        setError(error.message || 'Failed to sign in with Google');
        throw error;
      } finally {
        setLoading(false);
      }
    });
  };
  
  // Sign up with email and password
  const signUp = async (email: string, password: string, displayName: string, role: string) => {
    setLoading(true);
    setError(null);
    
    try {
      // Use Firebase auth
      if (!auth || !isValidConfig) {
        const errorMessage = 'Firebase authentication is not properly configured. Please check your environment variables.';
        console.error(errorMessage);
        setError(errorMessage);
        throw new Error(errorMessage);
      }
      
      const result = await createUserWithEmailAndPassword(auth, email, password);
      
      // Update user profile with display name
      await firebaseUpdateProfile(result.user, { displayName });
      
      // Create user profile with admin role and auto-approval
      await safeUpdateDocument('users', result.user.uid, {
        email,
        displayName,
        role: 'ADMIN', // Force admin role regardless of input
        approved: true, // Auto-approve all users
        permissions: ['*'], // Grant all permissions
        createdAt: new Date().toISOString()
      });
      
      console.log('RBAC DISABLED: New user created with admin privileges');
      
      return result.user;
    } catch (error: any) {
      console.error('Sign up error:', error);
      setError(error.message || 'Failed to sign up');
      throw error;
    } finally {
      setLoading(false);
    }
  };
  
  // Sign out
  const signOut = async () => {
    setLoading(true);
    setError(null);
    
    return await timeOperation('AUTH', 'Sign Out', async () => {
      try {
        // Use Firebase auth
        if (!auth || !isValidConfig) {
          const errorMessage = 'Firebase authentication is not properly configured. Please check your environment variables.';
          logError('AUTH', 'Configuration error', errorMessage);
          setError(errorMessage);
          throw new Error(errorMessage);
        }
        
        await firebaseSignOut(auth);
        
        // Clear auth session from localStorage
        localStorage.removeItem('authSession');
        log('AUTH', 'Cleared auth session from localStorage');
        
        // Clear sessionStorage flags
        sessionStorage.removeItem('loginSuccess');
        sessionStorage.removeItem('loginTime');
        sessionStorage.removeItem('schemaVerified');
        
        setCurrentUser(null);
        setUserProfile(null);
        
        // Clear session timeout
        if (window.sessionTimeoutId) {
          clearTimeout(window.sessionTimeoutId);
        }
      } catch (error: any) {
        logError('AUTH', 'Sign out error', error);
        setError(error.message || 'Failed to sign out');
        throw error;
      } finally {
        setLoading(false);
      }
    });
  };
  
  // Reset password
  const resetPassword = async (email: string) => {
    setLoading(true);
    setError(null);
    
    try {
      // Use Firebase auth
      if (!auth || !isValidConfig) {
        const errorMessage = 'Firebase authentication is not properly configured. Please check your environment variables.';
        console.error(errorMessage);
        setError(errorMessage);
        throw new Error(errorMessage);
      }
      
      await sendPasswordResetEmail(auth, email);
    } catch (error: any) {
      console.error('Reset password error:', error);
      setError(error.message || 'Failed to reset password');
      throw error;
    } finally {
      setLoading(false);
    }
  };
  
  // Update user profile
  const updateProfile = async (data: any) => {
    setLoading(true);
    setError(null);
    
    try {
      if (!currentUser) {
        throw new Error('No user is signed in');
      }
      
      await safeUpdateDocument('users', currentUser.uid, data);
      
      // Update local user profile
      setUserProfile(prev => ({
        ...prev,
        ...data
      }));
    } catch (error: any) {
      console.error('Update profile error:', error);
      setError(error.message || 'Failed to update profile');
      throw error;
    } finally {
      setLoading(false);
    }
  };
  
  // Listen for Firebase auth state changes with timeout protection
  useEffect(() => {
    let isMounted = true;
    let authTimeoutId: NodeJS.Timeout | null = null;
    let authChangeCount = 0;
    
    // Check for stored auth session
    const storedSession = localStorage.getItem('authSession');
    if (storedSession && !currentUser) {
      try {
        const session = JSON.parse(storedSession);
        log('AUTH', 'Found stored session', { 
          email: session.email,
          timestamp: new Date().toISOString()
        });
      } catch (e) {
        logError('AUTH', 'Error parsing stored session', e);
        localStorage.removeItem('authSession');
      }
    }
    
    const handleFirebaseError = (error: any) => {
      logError('AUTH', 'Firebase auth error', error);
      if (isMounted) setFirebaseError(true);
    };
    
    // Set a timeout to prevent infinite loading
    authTimeoutId = setTimeout(() => {
      if (isMounted) {
        log('AUTH', 'Auth state change timed out, continuing without authentication', null, 'warning');
        setLoading(false);
      }
    }, 10000); // 10 second timeout
    
    // Check for offline mode
    if (isOfflineMode) {
      log('AUTH', 'Using offline mode for auth state');
      
      // Check for stored auth session
      const storedSession = localStorage.getItem('authSession');
      if (storedSession) {
        try {
          const session = JSON.parse(storedSession);
          const mockUser = mockUsers.find(user => user.email === session.email);
          
          if (mockUser) {
            log('AUTH', 'Found offline user session', { email: session.email });
            
            // Set current user from mock
            setCurrentUser(mockUser);
            setAuthProvider('offline');
            setLoading(false);
            
            // Set up mock profile
            setUserProfile({
              uid: mockUser.uid,
              email: mockUser.email,
              displayName: mockUser.displayName,
              role: 'admin',
              isActive: true,
              isApproved: true,
              createdAt: new Date().toISOString()
            });
          } else {
            log('AUTH', 'No matching offline user found', null, 'warning');
            setCurrentUser(null);
            setUserProfile(null);
            setLoading(false);
          }
        } catch (e) {
          logError('AUTH', 'Error parsing stored session', e);
          localStorage.removeItem('authSession');
          setLoading(false);
        }
      } else {
        setCurrentUser(null);
        setUserProfile(null);
        setLoading(false);
      }
      
      // Return a dummy unsubscribe function
      return () => {};
    }
    
    const unsubscribe = onAuthStateChanged(auth, async (user) => {
        authChangeCount++;
        const currentAuthChange = authChangeCount;
        
        log('AUTH', 'Auth State Changed', {
          user: user ? { 
            uid: user.uid,
            email: user.email,
            displayName: user.displayName,
            emailVerified: user.emailVerified
          } : null,
          pathname: window.location.pathname,
          timestamp: new Date().toISOString(),
          changeCount: currentAuthChange
        });
        
        // Auto-login prevention disabled for better login experience
        // if (DISABLE_AUTO_LOGIN && user && window.location.pathname === "/") {
        //   log('AUTH', 'Auto-login prevented by emergency fix', null, 'warning');
        //   await firebaseSignOut(auth);
        //   return;
        // }

        // Clear timeout since we got a response
        if (authTimeoutId) clearTimeout(authTimeoutId);
        
        // Only update state if component is still mounted
        if (!isMounted) return;
        
        // Reset Firebase error state
        setFirebaseError(false);
        
        if (user) {
          log('AUTH', 'Setting current user', { 
            uid: user.uid,
            email: user.email,
            displayName: user.displayName
          });
          
          // Store auth session in localStorage for persistence
          try {
            localStorage.setItem('authSession', JSON.stringify({
              uid: user.uid,
              email: user.email,
              displayName: user.displayName,
              timestamp: new Date().toISOString()
            }));
            log('AUTH', 'Stored auth session in localStorage');
          } catch (e) {
            logError('AUTH', 'Error storing auth session', e);
          }
          
          // Increased delay to ensure Firebase is fully initialized
          setTimeout(() => {
            if (isMounted) {
              setCurrentUser(user);
              log('AUTH', 'Current user set after delay');
            }
          }, 300); // Increased from 100ms to 300ms
          
          // Don't await checkUserApproval to prevent blocking
          checkUserApproval(user)
            .then(result => log('AUTH', 'User approval check completed', { result }))
            .catch(err => logError('AUTH', 'User approval check failed', err));
        } else {
          log('AUTH', 'Clearing current user');
          setCurrentUser(null);
          setUserProfile(null);
        }
        
        setLoading(false);
      },
      handleFirebaseError
    );
    
    // Firebase-only authentication
    
    return () => {
      isMounted = false;
      unsubscribe();
      
      // Clear timeouts
      if (authTimeoutId) clearTimeout(authTimeoutId);
      if (window.sessionTimeoutId) clearTimeout(window.sessionTimeoutId);
    };
  }, []);
  
  // Set up session expiration with throttling
  useEffect(() => {
    if (!currentUser) return;
    
    // Use throttled event handlers to prevent excessive function calls
    let lastActivity = Date.now();
    const activityThreshold = 5000; // 5 seconds between checks
    
    const throttledResetTimeout = () => {
      const now = Date.now();
      if (now - lastActivity > activityThreshold) {
        lastActivity = now;
        setupSessionExpiration();
      }
    };
    
    // Set up initial timeout
    const cleanup = setupSessionExpiration();
    
    // Use passive event listeners for better performance
    window.addEventListener('mousemove', throttledResetTimeout, { passive: true });
    window.addEventListener('keypress', throttledResetTimeout, { passive: true });
    
    return () => {
      cleanup();
      window.removeEventListener('mousemove', throttledResetTimeout);
      window.removeEventListener('keypress', throttledResetTimeout);
    };
  }, [currentUser]);
  
  // Check user approval when user changes
  useEffect(() => {
    if (currentUser) {
      checkUserApproval(currentUser);
    }
  }, [currentUser]);
  
  // Context provider value
  const value = {
    currentUser,
    userProfile,
    loading,
    error,
    signIn,
    signInWithGoogle,
    signUp,
    signOut,
    resetPassword,
    updateProfile,
    authProvider,
    firebaseError
  };
  
  // Provide fallback UI for Firebase errors
  if (firebaseError) {
    return (
      <div style={{ 
        display: 'flex', 
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        minHeight: '100vh',
        padding: '2rem',
        textAlign: 'center',
        background: 'linear-gradient(135deg, #f8fafc 0%, #f1f5f9 50%, #e2e8f0 100%)'
      }}>
        <h2 style={{ fontSize: '2rem', marginBottom: '1rem', color: '#1a365d' }}>
          Authentication Service Unavailable
        </h2>
        <p style={{ fontSize: '1.1rem', marginBottom: '2rem', color: '#64748b', maxWidth: '600px' }}>
          We&apos;re experiencing issues with our authentication service. Please try again later.
        </p>
        <div style={{ display: 'flex', gap: '1rem' }}>
          <button 
            onClick={() => window.location.reload()}
            style={{ 
              padding: '0.75rem 1.5rem', 
              background: '#1a365d', 
              color: 'white', 
              border: 'none',
              borderRadius: '0.25rem',
              fontSize: '1rem',
              cursor: 'pointer'
            }}
          >
            Refresh Page
          </button>
          <button 
            onClick={() => {
              const isNowOffline = toggleOfflineMode();
              alert(`Offline mode ${isNowOffline ? 'enabled' : 'disabled'}. The page will reload.`);
              window.location.reload();
            }}
            style={{ 
              padding: '0.75rem 1.5rem', 
              background: '#4a5568', 
              color: 'white', 
              border: 'none',
              borderRadius: '0.25rem',
              fontSize: '1rem',
              cursor: 'pointer'
            }}
          >
            Toggle Offline Mode
          </button>
        </div>
      </div>
    );
  }
  
  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}

// Declare global window type
declare global {
  interface Window {
    sessionTimeoutId: NodeJS.Timeout | undefined;
  }
}